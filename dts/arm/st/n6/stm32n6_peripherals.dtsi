/*
 * Copyright (c) 2024 STMicroelectronics
 *
 * SPDX-License-Identifier: Apache-2.0
 */

rcc: rcc@6028000 {
	compatible = "st,stm32n6-rcc";
	clocks-controller;
	#clock-cells = <2>;
	reg = <0x06028000 0x2000>;

	rctl: reset-controller {
		compatible = "st,stm32-rcc-rctl";
		#reset-cells = <1>;
	};
};

exti: interrupt-controller@6025000 {
	compatible = "st,stm32g0-exti", "st,stm32-exti";
	interrupt-controller;
	#interrupt-cells = <1>;
	#address-cells = <1>;
	reg = <0x06025000 0x400>;
	num-lines = <16>;
	interrupts = <20 0>, <21 0>, <22 0>, <23 0>,
			<24 0>, <25 0>, <26 0>, <27 0>,
			<28 0>, <29 0>, <30 0>, <31 0>,
			<32 0>, <33 0>, <34 0>, <35 0>;
	interrupt-names = "line0", "line1", "line2", "line3",
				"line4", "line5", "line6", "line7",
				"line8", "line9", "line10", "line11",
				"line12", "line13", "line14", "line15";
	line-ranges = <0 1>, <1 1>, <2 1>, <3 1>,
			<4 1>, <5 1>, <6 1>, <7 1>,
			<8 1>, <9 1>, <10 1>, <11 1>,
			<12 1>, <13 1>, <14 1>, <15 1>;
};

pinctrl: pin-controller@6020000 {
	compatible = "st,stm32-pinctrl";
	#address-cells = <1>;
	#size-cells = <1>;
	reg = <0x06020000 0x2000>;
	ranges = <0x0 0x06020000 0x10000>;

	gpioa: gpio@0 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00000000 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000001>;
	};

	gpiob: gpio@400 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00000400 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000002>;
	};

	gpioc: gpio@800 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00000800 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000004>;
	};

	gpiod: gpio@c00 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00000c00 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000008>;
	};

	gpioe: gpio@1000 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00001000 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000010>;
	};

	gpiof: gpio@1400 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00001400 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000020>;
	};

	gpiog: gpio@1800 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00001800 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000040>;
	};

	gpioh: gpio@1c00 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00001c00 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00000080>;
	};

	gpion: gpio@3400 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00003400 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00002000>;
	};

	gpioo: gpio@3800 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00003800 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00004000>;
	};

	gpiop: gpio@3c00 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00003C00 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00008000>;
	};

	gpioq: gpio@4000 {
		compatible = "st,stm32-gpio";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x00004000 0x400>;
		clocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00010000>;
	};
};

usart1: serial@2001000 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x02001000 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00000010>;
	resets = <&rctl STM32_RESET(APB2, 4U)>;
	interrupts = <159 0>;
	status = "disabled";
};

usart2: serial@4400 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00004400 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00020000>;
	resets = <&rctl STM32_RESET(APB1L, 17U)>;
	interrupts = <160 0>;
	status = "disabled";
};

usart3: serial@4800 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00004800 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00040000>;
	resets = <&rctl STM32_RESET(APB1L, 18U)>;
	interrupts = <161 0>;
	status = "disabled";
};

uart4: serial@4c00 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00004C00 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00080000>;
	resets = <&rctl STM32_RESET(APB1L, 19U)>;
	interrupts = <162 0>;
	status = "disabled";
};

uart5: serial@5000 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00005000 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00100000>;
	resets = <&rctl STM32_RESET(APB1L, 20U)>;
	interrupts = <163 0>;
	status = "disabled";
};

usart6: serial@2001400 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x02001400 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00000020>;
	resets = <&rctl STM32_RESET(APB2, 5U)>;
	interrupts = <164 0>;
	status = "disabled";
};

uart7: serial@7800 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00007800 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x40000000>;
	resets = <&rctl STM32_RESET(APB1L, 30U)>;
	interrupts = <165 0>;
	status = "disabled";
};

uart8: serial@7c00 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x00007C00 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x80000000>;
	resets = <&rctl STM32_RESET(APB1L, 31U)>;
	interrupts = <166 0>;
	status = "disabled";
};

uart9: serial@2001800 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x02001800 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00000040>;
	resets = <&rctl STM32_RESET(APB2, 6U)>;
	interrupts = <167 0>;
	status = "disabled";
};

usart10: serial@2001c00 {
	compatible = "st,stm32-usart", "st,stm32-uart";
	reg = <0x02001C00 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00000080>;
	resets = <&rctl STM32_RESET(APB2, 7U)>;
	interrupts = <168 0>;
	status = "disabled";
};

spi1: spi@2003000 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x02003000 0x400>;
	interrupts = <153 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00001000>;
	status = "disabled";
};

spi2: spi@3800 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x00003800 0x400>;
	interrupts = <154 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00004000>;
	status = "disabled";
};

spi3: spi@3c00 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x00003C00 0x400>;
	interrupts = <155 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00008000>;
	status = "disabled";
};

spi4: spi@2003400 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x02003400 0x400>;
	interrupts = <156 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00002000>;
	status = "disabled";
};

spi5: spi@2005000 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x02005000 0x400>;
	interrupts = <157 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB2 0x00100000>;
	status = "disabled";
};

spi6: spi@6001400 {
	compatible = "st,stm32h7-spi", "st,stm32-spi-fifo", "st,stm32-spi";
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x06001400 0x400>;
	interrupts = <158 0>;
	clocks = <&rcc STM32_CLOCK_BUS_APB4 0x00000020>;
	status = "disabled";
};

i2c1: i2c@5400 {
	compatible = "st,stm32-i2c-v2";
	clock-frequency = <I2C_BITRATE_STANDARD>;
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x00005400 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00200000>;
	interrupts = <100 0>, <101 0>;
	interrupt-names = "event", "error";
	status = "disabled";
};

i2c2: i2c@5800 {
	compatible = "st,stm32-i2c-v2";
	clock-frequency = <I2C_BITRATE_STANDARD>;
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x00005800 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00400000>;
	interrupts = <102 0>, <103 0>;
	interrupt-names = "event", "error";
	status = "disabled";
};

i2c3: i2c@5c00 {
	compatible = "st,stm32-i2c-v2";
	clock-frequency = <I2C_BITRATE_STANDARD>;
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x00005C00 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB1 0x00800000>;
	interrupts = <104 0>, <105 0>;
	interrupt-names = "event", "error";
	status = "disabled";
};

i2c4: i2c@6001c00 {
	compatible = "st,stm32-i2c-v2";
	clock-frequency = <I2C_BITRATE_STANDARD>;
	#address-cells = <1>;
	#size-cells = <0>;
	reg = <0x06001C00 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_APB4 0x00000080>;
	interrupts = <106 0>, <107 0>;
	interrupt-names = "event", "error";
	status = "disabled";
};

fdcan1: can@a000 {
	compatible = "st,stm32h7-fdcan";
	reg = <0x0000A000 0x400>, <0x0000C000 0x2800>;
	reg-names = "m_can", "message_ram";
	interrupts = <180 0>, <181 0>, <186 0>;
	interrupt-names = "int0", "int1", "calib";
	clocks = <&rcc STM32_CLOCK_BUS_APB1_2 0x00000100>;
	bosch,mram-cfg = <0x0 28 8 3 3 0 3 3>;
	sample-point = <875>;
	sample-point-data = <875>;
	status = "disabled";
};

fdcan2: can@a400 {
	compatible = "st,stm32h7-fdcan";
	reg = <0x0000A400 0x400>, <0x0000C000 0x2800>;
	reg-names = "m_can", "message_ram";
	interrupts = <182 0>, <183 0>;
	interrupt-names = "int0", "int1";
	clocks = <&rcc STM32_CLOCK_BUS_APB1_2 0x00000100>;
	bosch,mram-cfg = <0x0 28 8 3 3 0 3 3>;
	sample-point = <875>;
	sample-point-data = <875>;
	status = "disabled";
};

fdcan3: can@e800 {
	compatible = "st,stm32h7-fdcan";
	reg = <0x0000E800 0x400>, <0x0000C000 0x2800>;
	reg-names = "m_can", "message_ram";
	interrupts = <184 0>, <185 0>;
	interrupt-names = "int0", "int1";
	clocks = <&rcc STM32_CLOCK_BUS_APB1_2 0x00000100>;
	bosch,mram-cfg = <0x0 28 8 3 3 0 3 3>;
	sample-point = <875>;
	sample-point-data = <875>;
	status = "disabled";
};

xspi1: xspi@8025000 {
	compatible = "st,stm32-xspi";
	reg = <0x08025000 0x1000>;
	interrupts = <170 0>;
	clock-names = "xspix", "xspi-ker", "xspi-mgr";
	clocks = <&rcc STM32_CLOCK_BUS_AHB5 0x00000020>,
		 <&rcc STM32_SRC_CKPER XSPI1_SEL(1)>,
		 <&rcc STM32_CLOCK_BUS_AHB5 0x00002000>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "disabled";
};

xspi2: xspi@802a000 {
	compatible = "st,stm32-xspi";
	reg = <0x802A000 0x1000>;
	interrupts = <171 0>;
	clock-names = "xspix", "xspi-ker", "xspi-mgr";
	clocks = <&rcc STM32_CLOCK_BUS_AHB5 0x00001000>,
		 <&rcc STM32_SRC_CKPER XSPI2_SEL(1)>,
		 <&rcc STM32_CLOCK_BUS_AHB5 0x00002000>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "disabled";
};

sdmmc1: sdmmc@8027000 {
	compatible = "st,stm32-sdmmc";
	reg = <0x8027000 0x1000>;
	clocks = <&rcc STM32_CLOCK_BUS_AHB5 0x00000100>;
	resets = <&rctl STM32_RESET(AHB5, 8U)>;
	interrupts = <174 0>;
	status = "disabled";
};

sdmmc2: sdmmc@8026800 {
	compatible = "st,stm32-sdmmc";
	reg = <0x8026800 0x400>;
	clocks = <&rcc STM32_CLOCK_BUS_AHB5 0x00000080>;
	resets = <&rctl STM32_RESET(AHB5, 7U)>;
	interrupts = <175 0>;
	status = "disabled";
};
